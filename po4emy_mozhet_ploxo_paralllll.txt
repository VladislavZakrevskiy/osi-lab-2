ГИПОТЕЗЫ: 
1) у меня есть достаточно много последовательных участков кода

Предполагаю, что работает закон Амдала: 
S = 1/(a + (1-a)/p)
условно a = 50%, p = 10;
значит S = 1/(0.5 + (1-0.5)/10) = 1.81

Расчеты в теории (Амдал) и бенчмарк похожи на правду
Амдал: 1.81
Бенч: max = 1.934

Антигипотеза 2) Точно не проц тротлит, пропорционально 2к и 4к примерно одинаково
2к я делаю раньше и она меньше, а 4к примерно то же самое выдает 

3) к 1п: сокращается количество параллельных вычислений к концу
На 150 строке в determinant.c есть условие rows_to_process < max_threads * 2
Это я так контролирую объем данных который будет считаться параллельно
если их мало нам невыгодно считать параллельно, легче тупо в 1 поток
Вот я и придумал такое условие, оно правда работает, без него выдает около 1.3, с ним 1.8
2 выбрана опытным путем, вполне можно и 1.5, и 3, там с точностью до .05 разница
в среднем 2 лучше всех себя показывает, поэтому выбрал ее

